#!/usr/bin/env bash

set -eo pipefail

main() {
    source_metaconfigs "${target}.metaconfig"

    write_config "$target"
}

source_metaconfigs() {
    # find all configs up the directory tree and source tompost first
    for file in $(findup "$1" | tac); do
        source "$file"
    done
}

write_config() {
    # find the first template up the directory tree
    local template_glob="${target}.template"
    local template=$(findup "$template_glob" | tac | head -n1)
    if [ -f "$template" ]; then
        local target_tmp="${target}.tmp"
        rm --force "$target_tmp"
        # http://stackoverflow.com/questions/10929453/read-a-file-line-by-line-assigning-the-value-to-a-variable
        # Explanation:
        # IFS='' (or IFS=) prevents leading/trailing whitespace from being trimmed.
        # -r prevents backslash escapes from being interpreted.
        # || [[ -n $line ]] prevents the last line from being ignored if it doesn't end with a \n (since read returns a non-zero exit code when it encounters EOF).
        while IFS='' read -r line || [[ -n "$line" ]]; do
            local echo_cmd="echo $line >> $target_tmp"
            eval $echo_cmd
        done < "$template"
        mv --force --backup "$target_tmp" "$target"
    else
        echo "template matching $template_glob not found"
        exit 1
    fi
}

print_help() {
    echo "Usage: $(basename $0) -h | FILE"
    echo "    FILE - target file"
    echo ""
    echo "Sources all FILE.metaconfig found up the directory tree, starting from the tompost one, and writes FILE based on closest FILE.template found up the directory tree"
}

target="$1"
if [ -z "$target" ] || [ "$target" == "-h" ]; then
    print_help
    exit 1
fi

main

